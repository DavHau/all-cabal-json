{
  "description": {
    "spec-version": {
      "Right": ">=1.10"
    },
    "package": {
      "name": "syntax",
      "version": [
        1,
        0,
        0,
        0
      ]
    },
    "license": {
      "Right": "MIT"
    },
    "license-files": [
      "LICENSE"
    ],
    "copyright": "Paweł Nowak 2014",
    "maintainer": "Paweł Nowak <pawel834@gmail.com>",
    "author": "Paweł Nowak",
    "stability": "",
    "tested-with": [],
    "homepage": "",
    "pkg-url": "",
    "bug-reports": "",
    "source-repos": [
      {
        "kind": {},
        "type": "Git",
        "location": "git@github.com:Pawel834/syntax.git",
        "module": null,
        "branch": null,
        "tag": null,
        "subdir": null
      }
    ],
    "synopsis": "Reversible parsing and pretty-printing.",
    "description": "\n\"syntax\" allows you to write a single syntax description and instantiate is both as a parser and a pretty printer.\n\nSyntax descriptions are written in applicative or arrow style. The library uses a custom typeclass hierarchy, provided\nby the \"semi-iso\" package. Most of the time you will be using operators like '/$/', '/*/' and '/+/' (= '<|>'), just\nlike parser combinators. When more power is needed - e.g. when the syntax depends on the parsed or printed value -\nyou turn to arrows.\n\nSemi-isomorphisms from \"semi-iso\" are the basic building block of syntax descriptions. I recommend reading\nthe hackage page of \"semi-iso\" first, as it contains much more information.\n\nOnce you write a syntax description (polymorphic in the syntax category) you can instantiate it both as a parser or as\na pretty-printer. The library \"syntax-attoparsec\" gives you the ability to extract an Attoparsec parser. Pretty-printing\nis implemented by the \"syntax-printer\" library, which uses Text and ByteString builders. (Note that formatting is handled\nby \"syntax\" itself, not by the printer library)\n\nAdvanced formatting and parsing (for example indentation, haskell layout rule) is implemented as category transformers\n(similar to monad transformers). Currently only simple indentation is implemented (in \"Data.Syntax.Indent\") - basically\na reader category transformer that tracks current indentation level. I plan on implementing Haskell layout rule in the\nfuture.\n\nThe library can work with both text and binary data. Alas, there are no binary combinators implemented yet.\n\nEXAMPLES! See @syntax-example@ and @syntax-example-json@ for examples.\n\n* \"syntax-example\" implements a simple lambda calculus.\n\n* \"syntax-example-json\" implements a json parser and pretty printer.",
    "category": "Data",
    "custom-fields": [
      [
        "x-revision",
        "2"
      ]
    ],
    "build-type-raw": "Simple",
    "custom-setup": null,
    "library": null,
    "sublibraries": [],
    "executables": [],
    "foreign-libs": [],
    "test-suites": [],
    "benchmarks": [],
    "data-files": [],
    "data-dir": ".",
    "extra-source-files": [],
    "extra-tmp-files": [],
    "extra-doc-files": []
  },
  "library": {
    "condTreeData": {
      "name": {},
      "exposed-modules": [
        [
          "Data",
          "Syntax"
        ],
        [
          "Data",
          "Syntax",
          "Char"
        ],
        [
          "Data",
          "Syntax",
          "Combinator"
        ],
        [
          "Data",
          "Syntax",
          "Indent"
        ]
      ],
      "re-exported-modules": [],
      "signatures": [],
      "exposed": true,
      "visibility": "LibraryVisibilityPublic",
      "build-info": {
        "buildable": true,
        "buildTools": [],
        "buildToolDepends": [],
        "cppOptions": [],
        "asmOptions": [],
        "cmmOptions": [],
        "ccOptions": [],
        "cxxOptions": [],
        "ldOptions": [],
        "pkgconfigDepends": [],
        "frameworks": [],
        "extraFrameworkDirs": [],
        "asmSources": [],
        "cmmSources": [],
        "cSources": [],
        "cxxSources": [],
        "jsSources": [],
        "hsSourceDirs": [],
        "otherModules": [],
        "virtualModules": [],
        "autogenModules": [],
        "defaultLanguage": "Haskell2010",
        "otherLanguages": [],
        "defaultExtensions": [],
        "otherExtensions": [],
        "oldExtensions": [],
        "extraLibs": [],
        "extraGHCiLibs": [],
        "extraBundledLibs": [],
        "extraLibFlavours": [],
        "extraDynLibFlavours": [],
        "extraLibDirs": [],
        "includeDirs": [],
        "includes": [],
        "autogenIncludes": [],
        "installIncludes": [],
        "options": [
          [],
          []
        ],
        "profOptions": [
          [],
          []
        ],
        "sharedOptions": [
          [],
          []
        ],
        "staticOptions": [
          [],
          []
        ],
        "customFieldsBI": [],
        "targetBuildDepends": [
          {
            "package-name": "base",
            "version-range": ">=4 && <5",
            "library": [
              {}
            ]
          },
          {
            "package-name": "mono-traversable",
            "version-range": "-any",
            "library": [
              {}
            ]
          },
          {
            "package-name": "lens",
            "version-range": ">=4",
            "library": [
              {}
            ]
          },
          {
            "package-name": "semi-iso",
            "version-range": ">=1",
            "library": [
              {}
            ]
          },
          {
            "package-name": "scientific",
            "version-range": ">=0.3",
            "library": [
              {}
            ]
          },
          {
            "package-name": "text",
            "version-range": "-any",
            "library": [
              {}
            ]
          },
          {
            "package-name": "vector",
            "version-range": "-any",
            "library": [
              {}
            ]
          }
        ],
        "mixins": []
      }
    },
    "condTreeConstraints": [
      {
        "package-name": "base",
        "version-range": ">=4 && <5",
        "library": [
          {}
        ]
      },
      {
        "package-name": "mono-traversable",
        "version-range": "-any",
        "library": [
          {}
        ]
      },
      {
        "package-name": "lens",
        "version-range": ">=4",
        "library": [
          {}
        ]
      },
      {
        "package-name": "semi-iso",
        "version-range": ">=1",
        "library": [
          {}
        ]
      },
      {
        "package-name": "scientific",
        "version-range": ">=0.3",
        "library": [
          {}
        ]
      },
      {
        "package-name": "text",
        "version-range": "-any",
        "library": [
          {}
        ]
      },
      {
        "package-name": "vector",
        "version-range": "-any",
        "library": [
          {}
        ]
      }
    ],
    "condTreeComponents": []
  }
}
