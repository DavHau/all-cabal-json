{
  "description": {
    "spec-version": {
      "Right": ">=1.10.1"
    },
    "package": {
      "name": "pipes",
      "version": [
        1,
        0
      ]
    },
    "license": {
      "Right": "OtherLicense"
    },
    "license-files": [
      "LICENSE"
    ],
    "copyright": "2012 Gabriel Gonzalez",
    "maintainer": "Gabriel439@gmail.com",
    "author": "Gabriel Gonzalez",
    "stability": "Experimental",
    "tested-with": [
      {
        "compiler": "GHC",
        "versionRange": "==7.0.3"
      }
    ],
    "homepage": "",
    "pkg-url": "",
    "bug-reports": "mailto:Gabriel439@gmail.com",
    "source-repos": [
      {
        "kind": {},
        "type": "Git",
        "location": "https://github.com/Gabriel439/Haskell-Pipes-Library",
        "module": null,
        "branch": null,
        "tag": null,
        "subdir": null
      }
    ],
    "synopsis": "Compositional pipelines",
    "description": "\\\"Iteratees done right\\\".  This library implements\niteratees\\/enumerators\\/enumeratees simply and elegantly, but uses different\nnaming conventions.\n\nAdvantages over traditional iteratee implementations:\n\n* /Simpler semantics/: There is only one data type ('Pipe'), two primitives\n('await' and 'yield'), and only one way to compose 'Pipe's ('.').  In fact,\nthis library introduces no new operators, using only its 'Monad' and\n'Category' instances to implement all behavior.\n\n* /Clearer naming conventions/: Enumeratees are called 'Pipe's, Enumerators\nare 'Producer's, and Iteratees are 'Consumer's.  'Producer's and 'Consumer's\nare just type synonyms for 'Pipe's with either the input or output end\nclosed.\n\n* /Pipes are Categories/: You compose them using ordinary composition.\nThere are actually two 'Category' instances: one for 'Lazy' composition and\none for 'Strict' composition.  Both instances satisfy the 'Category' laws.\n\n* /Intuitive/: Pipe composition is easier to reason about because it is a true\n'Category'.  Composition works seamlessly and you don't have to worry about\nrestarting iteratees, feeding new input, etc.  \\\"It just works\\\".\n\n* /\"Vertical\" concatenation works flawlessly on everything/: ('>>')\nconcatenates 'Pipe's, but since everything is a 'Pipe', you can use it to\nconcatenate 'Producer's, 'Consumer's, and even intermediate 'Pipe' stages.\nVertical Concatenation always works the way you expect, picking up where the\nprevious 'Pipe' left off.\n\n* /Symmetric implementation/: Most iteratee libraries are either\nenumerator-driven or iteratee-driven.  'Pipe's are implemented\nsymmetrically, which is why they can be composed with either 'Lazy'\n('Consumer'-driven) or 'Strict' ('Producer'-driven) semantics.\n\nCheck out \"Control.Pipe\" for a copious introduction (in the spirit of the\n@iterIO@ library) and \"Control.Pipe.Common\" for the actual implementation.\n\nThis library does not yet provide convenience 'Pipe's for common operations,\nbut they are forthcoming.  However, there are several examples in the\ndocumentation to get you started and I encourage you to write your own to see\nhow easy they are to write.",
    "category": "Control, Enumerator",
    "custom-fields": [],
    "build-type-raw": "Simple",
    "custom-setup": null,
    "library": null,
    "sublibraries": [],
    "executables": [],
    "foreign-libs": [],
    "test-suites": [],
    "benchmarks": [],
    "data-files": [],
    "data-dir": ".",
    "extra-source-files": [],
    "extra-tmp-files": [],
    "extra-doc-files": []
  },
  "library": {
    "condTreeData": {
      "name": {},
      "exposed-modules": [
        [
          "Control",
          "Pipe"
        ],
        [
          "Control",
          "Pipe",
          "Common"
        ]
      ],
      "re-exported-modules": [],
      "signatures": [],
      "exposed": true,
      "visibility": "LibraryVisibilityPublic",
      "build-info": {
        "buildable": true,
        "buildTools": [],
        "buildToolDepends": [],
        "cppOptions": [],
        "asmOptions": [],
        "cmmOptions": [],
        "ccOptions": [],
        "cxxOptions": [],
        "ldOptions": [],
        "pkgconfigDepends": [],
        "frameworks": [],
        "extraFrameworkDirs": [],
        "asmSources": [],
        "cmmSources": [],
        "cSources": [],
        "cxxSources": [],
        "jsSources": [],
        "hsSourceDirs": [],
        "otherModules": [],
        "virtualModules": [],
        "autogenModules": [],
        "defaultLanguage": "Haskell2010",
        "otherLanguages": [],
        "defaultExtensions": [],
        "otherExtensions": [],
        "oldExtensions": [],
        "extraLibs": [],
        "extraGHCiLibs": [],
        "extraBundledLibs": [],
        "extraLibFlavours": [],
        "extraDynLibFlavours": [],
        "extraLibDirs": [],
        "includeDirs": [],
        "includes": [],
        "autogenIncludes": [],
        "installIncludes": [],
        "options": [
          [
            "-O2"
          ],
          []
        ],
        "profOptions": [
          [],
          []
        ],
        "sharedOptions": [
          [],
          []
        ],
        "staticOptions": [
          [],
          []
        ],
        "customFieldsBI": [],
        "targetBuildDepends": [
          {
            "package-name": "base",
            "version-range": ">=4 && <5",
            "library": [
              {}
            ]
          },
          {
            "package-name": "mtl",
            "version-range": "-any",
            "library": [
              {}
            ]
          }
        ],
        "mixins": []
      }
    },
    "condTreeConstraints": [
      {
        "package-name": "base",
        "version-range": ">=4 && <5",
        "library": [
          {}
        ]
      },
      {
        "package-name": "mtl",
        "version-range": "-any",
        "library": [
          {}
        ]
      }
    ],
    "condTreeComponents": []
  }
}
